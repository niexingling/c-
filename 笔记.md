### 存储相关的关键字
>+ register、static、const、auto、extern
>>+ 1、register 是寄存器的意思 用register修饰的变量是寄存器变量
>>+ 即：在编译的时候告诉编译器这个变量是寄存器变量，尽量将其空间分配在寄存器中：
>>+ **注意：**
>>>+ (1):在定义变量不一定真的存放在寄存器中
>>>+ (2):cpu取数据的时候去寄存器中拿数据比去内存中拿数据要快
>>>+ (3):因为寄存器比较宝贵，所以不能定义寄存器数组
>>>+ (4):register只能修饰字符串及整型数组的，不能修饰浮点型
>>>+ (5):因为register修饰的变量可能存放在寄存器中不放在内存中，所以不能对寄存器变量取地址，因为存放在内存中的数据才又地址
>>+ 2、static 是静态的意思
>>>+ static可以修格斯全局变量、局部变量、函数、此函数修饰的函数存放在内存的静态区
>>+ 3、const
>>>+ const是常量的意思
>>>+ 用const修饰的变量是只读的，不能修改她的值
>>>+ const int a = 101;//在定义a的时候用const修饰 ，并赋值为101
>>>+ 从此以后，就不能在给a赋值
>>>+ a=111;//错误的
>>>+ const 可以修饰指针
>>+ auto int a;和int a 是等价的，auto关键字现在基本不用
>>+ extern是外部的意思，一般用于函数和全局变量的声明，
### 控制相关的关键字
>+ if
>+ else
>+ break
>+ continue
>+ for
>+ while
>+ do 
>+ switch
>+ case
>+ 条件控制语句：
>>+ if语句:if else
>>+ switch语句：switch case dafault
>+ 循环控制语句：
>>+ for while do goto
>+ 辅助控制语句：
>>+ break continue
###其他关键字
>+ sizeof
>+ typedef
>+ volatile
>>+ sizeof 是一个运算符可以获取所占内存空间大小(字节数)
>>+ typedef 作用是给一个已有的类型，重新起个类型名，并没又创造一个新的函数
>>>+ typeder short int INT16;
>>+ volatile易改变的意思
###数据类型
>+ 基本类型
>>+ char、short、int、long 、float、 double
>>>+ 定义一个char类型的变量并赋值，输出字符使用%c
>>>+ char 字符类型
>>>>+ char a ='w';
>>>>+ printf("a = %c\n,a);‘
>>>+ 定义一个short类型的变量并赋值
>>>>+ short b = 100;
>>>>+ printf("b = %d\n",b);
>>>+ 定义一个int类型的变量并赋值，输出int类型变量的值使用%d
>>>>+ int c = 999;
>>>>+ printf("c = %d\n",c);
>>>+ 定义一个long类型的变量并赋值，输出long类型变量的值使用%ld
>>>>+ long d = 5162621;
>>>>+ printf("d = %ld\n",d);
>>>+ 定义一个float类型的变量并赋值，输出float类型的变量的值使用%f
>>>+ 默认保留小数点后六位，并且可以四舍五入
>>>>+ float e = 3.1415926;
>>>>+ printf("e = %f\n",e);
>>>+ 定义一个double类型的变量并赋值输出double类型变量使用%lf
>>>>+ double f =31.1551156;
>>>>+ printf("f = %lf\n",f);
### 构造类型
>+ 基本类型
>>+ char、 short int、int、long int、float、double
>+ 构造类型
>>+ 概念：由若干个相同或不同类型数据结构构成的集合，这种数据类型称为构造类型
>>+ 例：int a[10];
>>+ 数组、结构体、共用体、枚举
>>+ 扩展：常量和变量
>>>+ 常量在程序运行过程中，其值不可改变的量
>>>+ 例：100 'a' "hello"
>>>>+ 整型 100,125,-100,0 
>>>>+ 实型 3.14，0.125f，-3.789
>>>>+ 字符型 'a','b','2'
>>>>+ 字符串 "a","ab","1232"
### ASCII表
>+ https://www.cnblogs.com/biaochen/p/11307382.html
### 动态内存分布malloc
>+ include<stdlib.h>
>+ void * malloc(size_t size);
>+ 像malloc申请的空间的大小是以字节为单位的
>+ 返回的结果是void* 需要类型转换为自己需要的类型
>+ （int*）malloc(n*sizeof(int))
>+ 最后归还内存 free();好借好还再借不难
### free()函数
>+ 把申请得来得空间还给‘系统’
>+ 申请过得空间，最终都应该要还
>+ 出来混迟早是要还得
>+ 只能还申请得来得空间得首地址
### putchar宏
>+ 如果一个宏的值中有其他宏的名字，也是会被替换的
>+ 如果一个宏的值超过一行，最后一行之前的行末需要加\
>+ 宏的值后面出现的注释不会被当作宏的值的一部分
### 没有值的宏
>+ #define _DEBUG
>+ 这类宏是用于条件编译的，后面有其他的编译预处理指令来检查这个宏是否已经被定义过了
### 预定义的宏
>+
### strlen
>+ size_t strlen(const char *s);
>+ 返回 S的字符串长度
### 自定义数据类型 typedef
>+ 声明新的类型的名字
>>+ 新的名字hi某种类型的别名
> 
>>+ 改善了程序的可读性
### 宏定义
>+ # define
>+ # #define<名字><值>
>+ 注意没有结尾的分号，因为不是c的语句
>+ 名字必须是一个单词，值可以是各种东西
>+ 在c语言的编译器开始编译之前，编译预处理程序（cpp）会把程序中的名字换成值
>+ 完全被的文本替换
>+ gcc -save-temps
### 头文件
>+ 把函数原型放到一个头文件（以.h结尾）中，在需要调用这个函数的源代码文件（.c文件）中#include这个头文件，就能让编译器在编译的时候知道函数的原型
### >#include的误区
>+ # #include不是用来引入库的
>+ stdio.h里只有printf的原型，printf的代码在另外的地方，某个.lib(windows)或.a(unix)中
>+ 现在的c语言编译器默认会引入所以的标准库
>+ # #include<stdio.h>只是为了让编译器知道printf函数的原型，保证你调用时给出的参数值是正确的类型
### 不对外公开的函数
>+ 在函数前面加上static就使得它为只能在所在的编译单元中被使用的函数
>+ 在全局变量前面加上static就使得她成为只能在所在的编译单元中被使用的全局变量
###声明函数extern 变量的声明
>+ int i;是变量的定义
>+ extern int i;声明函数
###声明和定义
>+ 声明是不产生代码的东西
>>+ 函数原型
>>+ 变量的声明
>>+ 结构的声明
>>+ 宏声明
>>+ 枚举声明
>>+ inline函数
>+ 定义是产生代码的东西
###头文件
>+ 只有声明可以被放在头文件中
>>+ 是规则不是法律
>+ 否则会造成一个项目中多个编译单元里有重名的实体
>>+ *某些编译器允许几个编译单元中存在同名的函数。或者用weak修饰符来强调这种的存在
###文件的读写fopen
>+ r  打开只读
>+ r+ 打开读写从文件头开始
>+ w 打开只写，如果不存在则新建，如果存在则清空
>+ w+ 打开读写，如果不存在则新建如果存在则清空
>+ a  打开追加，如果不存在则新建，如果存在则从文件尾开始
>+ ..x 只新建，如果文件已存在则不能打开
### 二进制文件
>+ 其实所有的文件最终都是二进制的
>+ 文本文件无非是用最简单的方式可以去读写的文件
>>+ more、tail
>>+ cat
>>+ vi
>+ 而二进制文件是需要专门的程序文件去读写的文件
>+ 文本文件的输入输出是格式化，可能经过转码
###按位运算
>+ c有这谢按位运算的运算符
>+ & 按位的与
>+ | 按位的或
>+ ~按位取反
>+ ^按位的异或
>+ <<左移
>+  .>>右移 
###按位与&
>+ 如果(x)i ==1并且(y)i==1,那么(x&y)i=1
>+ 否则的话(x&y)i =0;
>+ 按位与常用与两种应用:
>>+ 让某以为或某些位为0:x&0xFE
>>+ 取一个数中的一段： x& 0xFF 
### 左移<<
>+ i<<j
>+ i中所有的位向右移动j个位置，而右边填入0
>+ 所有小于int的类型，移位以int的方式来做结果是int
>+ x <<=1 等价于x * = 2
>+ x<<=n等价于x*=2N
>### c语言深度解剖
### Gcc的使用机器常用选项介绍
>+ 重点
>>+ 掌握c语言如何编程机器指令的过程
>>+ gcc工具的几个常用选项的意义
>+ 难点
>>+ c编译过程中在gcc工具上的体现
###GCC概述
>+ GCC最初的全名是GNU C Compiler
>+ 随着GCC支持的语言越来越多，它的名称变成了GNU compiler collection
>+ 翻译官 翻译组织
>+ gcc-o output
>+ gcc -o 输出的文件名，输入文件名
