### 存储相关的关键字
>+ register、static、const、auto、extern
>>+ 1、register 是寄存器的意思 用register修饰的变量是寄存器变量
>>+ 即：在编译的时候告诉编译器这个变量是寄存器变量，尽量将其空间分配在寄存器中：
>>+ **注意：**
>>>+ (1):在定义变量不一定真的存放在寄存器中
>>>+ (2):cpu取数据的时候去寄存器中拿数据比去内存中拿数据要快
>>>+ (3):因为寄存器比较宝贵，所以不能定义寄存器数组
>>>+ (4):register只能修饰字符串及整型数组的，不能修饰浮点型
>>>+ (5):因为register修饰的变量可能存放在寄存器中不放在内存中，所以不能对寄存器变量取地址，因为存放在内存中的数据才又地址
>>+ 2、static 是静态的意思
>>>+ static可以修格斯全局变量、局部变量、函数、此函数修饰的函数存放在内存的静态区
>>+ 3、const
>>>+ const是常量的意思
>>>+ 用const修饰的变量是只读的，不能修改她的值
>>>+ const int a = 101;//在定义a的时候用const修饰 ，并赋值为101
>>>+ 从此以后，就不能在给a赋值
>>>+ a=111;//错误的
>>>+ const 可以修饰指针
>>+ auto int a;和int a 是等价的，auto关键字现在基本不用
>>+ extern是外部的意思，一般用于函数和全局变量的声明，
### 控制相关的关键字
>+ if
>+ else
>+ break
>+ continue
>+ for
>+ while
>+ do 
>+ switch
>+ case
>+ 条件控制语句：
>>+ if语句:if else
>>+ switch语句：switch case dafault
>+ 循环控制语句：
>>+ for while do goto
>+ 辅助控制语句：
>>+ break continue
###其他关键字
>+ sizeof
>+ typedef
>+ volatile
>>+ sizeof 是一个运算符可以获取所占内存空间大小(字节数)
>>+ typedef 作用是给一个已有的类型，重新起个类型名，并没又创造一个新的函数
>>>+ typeder short int INT16;
>>+ volatile易改变的意思
###数据类型
>+ 基本类型
>>+ char、short、int、long 、float、 double
>>>+ 定义一个char类型的变量并赋值，输出字符使用%c
>>>+ char 字符类型
>>>>+ char a ='w';
>>>>+ printf("a = %c\n,a);‘
>>>+ 定义一个short类型的变量并赋值
>>>>+ short b = 100;
>>>>+ printf("b = %d\n",b);
>>>+ 定义一个int类型的变量并赋值，输出int类型变量的值使用%d
>>>>+ int c = 999;
>>>>+ printf("c = %d\n",c);
>>>+ 定义一个long类型的变量并赋值，输出long类型变量的值使用%ld
>>>>+ long d = 5162621;
>>>>+ printf("d = %ld\n",d);
>>>+ 定义一个float类型的变量并赋值，输出float类型的变量的值使用%f
>>>+ 默认保留小数点后六位，并且可以四舍五入
>>>>+ float e = 3.1415926;
>>>>+ printf("e = %f\n",e);
>>>+ 定义一个double类型的变量并赋值输出double类型变量使用%lf
>>>>+ double f =31.1551156;
>>>>+ printf("f = %lf\n",f);
### 构造类型
>+ 基本类型
>>+ char、 short int、int、long int、float、double
>+ 构造类型
>>+ 概念：由若干个相同或不同类型数据结构构成的集合，这种数据类型称为构造类型
>>+ 例：int a[10];
>>+ 数组、结构体、共用体、枚举
>>+ 扩展：常量和变量
>>>+ 常量在程序运行过程中，其值不可改变的量
>>>+ 例：100 'a' "hello"
>>>>+ 整型 100,125,-100,0 
>>>>+ 实型 3.14，0.125f，-3.789
>>>>+ 字符型 'a','b','2'
>>>>+ 字符串 "a","ab","1232"
### 变量
>+ 变量：其值可以改变的量称为变量
>+ 定义变量的方式：
>>+ 存储类型 数据类型 变量名；
>>+ 存储类型 数据类型 变量名= 变量或者常量；
>+ 变量在定义的时候要满足标识符的命名规则
>>+ (1)只能由字母、数字下划线组成
>>+ (2)首字母不能是数字
>>+ (3)不能和关键字相同
### 整型数据
>+ 十进制：以正常数字1-9开头，如5223
>+ 八进制：以数字零开头，如0123
>+ 十六进制：以0x开头，如0x1e
>+ 整型变量：
>>+  有无符号短整型（un/signed）short(int) 2个字节
>>+ 有无符号基本整型（un/signed）int  4个字节
>>+ 有无符号长整型（un/signed）long(int)4个字节（32位处理器）（64位处理器是8个字节）
### 实型数据
>+ 实型常量
>>+ 实型常量也称为实数或者浮点数
>>>+ 十进制形式：由数字和小数点组成0.0、0.12、5.0
>>>+ 指数形式： 123e3代表123*10的三次方
>>>+ 123e-3
>>>+ 不以f结尾的常量是double类型
>>>+ 以f结尾的常量（如3.14f）是float类型
>>+ 实型变量
>>>+ 单精度（float）和双精度（double）3.1415926
>>>+ float型：占四个字节，7位有效数字，指数-37到38
>>>+ double型：占8字节，16位有效数字，指数-307到308
### 字符数据
>+ 字符常量
>>+ 直接常量：用单引号括起来：如'a'、'b'、等
>>+ 转义字符：以反斜杠"\"开头，后跟一个或几个字符、如'\n''\t'等，分别代表换行、横向跳格，'\\'表示是\'%%'\'
>+ 字符变量：
>>+ 用char定义，每个字符变量分配一个字节的内存空间
>>+ 字符值以ASCII 码的形式存放在变量的内存单元中；
>>+ 注：char a;
>>>+ a = 'x';
>>>+ a变量中存放的是字节'x'在本质上是一致的
>+ 字符串常量
>>+ 是由双引号括起来的字符串序列，如"CHINA"、"哈哈哈"等都是合法的字符串常量
>+ 字符串常量与字符常量的不同
>>+ 'a'为字符常量,"a"为字符串常量
>>+ 每个字符串的结尾，编译器会自动的添加一个结束标志位'\0',即"a"包含两个字符'a'和'\0'
### 格式化输出字符
>+ %d 十进制由符号整数
>+ %ld 十进制long由符号整数
>+ %u 十进制无符号整数
>+ %o 以八进制表示的整数
>+ %x 以十六进制表示的整数
>+ %f float 型浮点数
>+ %lf double型浮点数
>+ %c 单个字符
>+ %s 字符串
>+ %p 指针的值
>+ 特殊应用：
>>+ %3d   %03d   %-3d   %5.2f
>>+ %3d 要求宽度为3位，如果不足3位，前面空格补齐，如果够3位，此语句无效
>>+ %03d 要求宽度位3位，如果不足3位，前面0补齐，如果够3位，此语句无效
>>+ %.2f 保留小数点后两位
### 类型转换
>+ 数据有不同的类型，不同类型数据之间进行混合运算时必然涉及到类型转换的问题
>+ 转换的方法有两种：
>>+ 自动转换：
>>>+ 遵循一定的规则，由编译系统自动完成
>>+ 自动转换的原则
>>>+ 1、占用内存字节数少（值域小）的类型，向占用内存字节数多（值域大）的类型转换，以保证精度不降低
>>+ （1）当表达式中出现了 char、short、int、int类型中的一种或多种，没有iqta类型了，参加运算的成员全部变成int类型的参加运算，结果也是int类型的
>>>+ 例：
>>>>+ /# include<stdio.h>
>>>>+ int main(int argc,char *argv[])
>>>>+ {
>>>>+ printf("%d\n",5/2);
>>>>+ return 0;
>>>>+  }
>>+ (2)当表达式中出现带小数的实数，参加运算的成员全部变成double类型的参加运算结果也是duoble类型
>>+ (3)当表达式中有有符号数 也有无符号数，参加运算的成员变成无符号数参加运算结果也是䧫数（表达式中无实数）
>>+ (4)在赋值语句中等号右边的类型自动转换位等号左边的类型
>>+ (5)注意自动类型转换都是在运算的过程中进行的临时的转换，并不会影响自动类型转换的变量的其结果的值和其类型
>>+ 强制类型转换：
>>>+ 吧表达式的运算结果强制转换成所需要的数据类型
>>+ 强制类型转换是通过类型转换运算来实现
>>>+ (类型说明符)(表达式)
>>>+ 功能：
>>>>+ 吧表达式的运算结果强制转换成类型说明符所示的类型
>>>>+ 例如：
>>>>>+ (float)a; //吧a的值转换为实型
>>>>>+ (int)(x+y);//吧x+y的结果值转换为整型
>>+ 注意：
>>>+ 类型说明符必须加括号
### 运算符
>+ 运算符
>>+ 用运算符将运算对象（也称操作数） 连接起来的、符合c语法规则的式子，称为c算数表达式运算对象包括常量、变量、函数等
>>>+ 例：
>>>+ a*b/c-1.5+'a'
>>+ 运算符的分类：
>>>+ (1)双目运算符:即参加运算的操作数有两个
>>>>+ 例：+
>>>>+ a+b
>>>+ (2)单目运算符：参加运算的操作数只有一个
>>>>+ ++自增运算符 给变量值+1
>>>>+ --自减运算符
>>>>+ int a =10;
>>>>+ a++;
>>>+ 三目运算符：即参加运算的操作数有3个
>>>>+ ()?():()
### 算数运算符
>+ + - * / % += -= *= /= %=
>+ 10%3 表达式的结果为1
>+ 复合运算符：
>>+ a+=3 相当于a=a+3
>>+ a*=6+8相当于a=a*(6+8)
### 关系运算符
>+ (>、<、==、>=、<=、！=)
>+ !=为不等于
>+ 一般用于判断条件是否满足或者循环语句
### 逻辑运算符
>+ 1、&&逻辑与
>>+ 两个条件都为真，则结果为真
>>+ if((a>b)&&(a<c))
>+ 2、|| 逻辑或
>>+ 两个条件至少有一个为真，则结果为真
>>+ if((a>b)||(a<c))
>+ 3、!逻辑非
>>+ if(!(a>b)){}
>+ 注意：
>>+ 在c语言不能这样写表达式10<a<100,需要通过逻辑运算符
>>+ a>10&&z<100
### 位运算符
>+ 1、& 按位与
>>+ 任何值与0得0，与1保持不变
>>+ 使某位清0
>>+ 0101 1011& 10110100 0001 0000
>+ 2、|按位或
>>+ 任何值或1得1 ，或0保持不变
>>+ 0101 0011 | 10110100 1111 0111
>+ 3、~按位取反
>>+ 1变0 ， 0变1
>>+ 0101 1101~ 1010 0010
>+ 4、^按位异或
>>+ 相异得1，相同得0
>>+ 1001 1100^0101 1010  1100 0110
>+5、位移
>>+ />>右移
>>+ <<左移
>>+ 注意右移分：逻辑右移、算数右移
>>>+ (1)、右移
>>>+ 算数右移 高位补0，低位溢出
>>>+ 算数右移 高位补符号位，低位溢出（有符号）
### 条件运算符
>+ ()?():()
>+ A?B:C
>+ 如果？前边得表达式成立，整个表达式得值，是？和：之间得表达式得结果
>+ 否则是：之后得表达式得结果
>+ 首先判断表达式A得结果，如果结果位真，则执行表达式B，如果表达式A为假，则执行表达式C
>+ 条件运算符其实就是一个简单得if else语句
### 逗号运算符
>+ (...,...,)
>+ 例如：A=（B,C,D）
>+ 先运行表达式B，在运行表达式C，最后运行表达式D，最终变量A得值为表达式D的值
### 自增自减运算符
>+ 这个就不写了，这个没必要写了
### 运算符优先级表
>+ https://baike.baidu.com/item/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/4752611?fr=aladdin#3
### 控制语句
>+ if语句
>+ 形式：
>>+ (1) if(条件表达式)
>>+ { 语句一
>>+ 语句二
>>+ }
>+ if else 语句的作用是，如果if的条件成立，执行if后面{}内的语句，否则执行else后的语句
>+ 错误：if和else之间只能又一条语句，如果有多条语句的话加大括号
>+ 注意:if和else之间只能有一条语句，或者有一个复合语句，否则编译会出错
### switch 语句
>>+ switch (表达式)//表达式只能是字符型或整型的(short int    int long int)
>>+ {
>>+ case常量表达式1：
>>+ 语句一
>>+ break;
>>+ case常量表达式2：
>>+ 语句2；
>>+ break;
>>+ default: 语句3;break;
>>+   }
>+
>+ 运行顺序：将常量表达式的值语句switch后面的表达式的值对比，如果表达式的值刚好等于case后面的某一个值，就会立即去执行case后面的语句，如果都不是，则会执行default后面的语句
>+ 注意事项：
>>+ （1）switch后面的表达式不能是浮点型，只能是整型的
>>+  (2)如果case后面的常量表达式与switch的表达式的值都不相同，则执行执行default后面的语句
>>+  (3)每一个case执行结束后理论上必须跟一个break，作用就是跳出整个switch语句
>>+  (4)case后面如果语句很多，不需要加大括号
>+ 注意：break 的使用 如果不加break，当要执行case语句时，执行完毕后会接着下一个case后的语句执行，直到遇见break为止，否则会一直执行 
###循环控制语句相关的关键字
>+ 1、for循环
>>+ for(表达式;表达式1;表达式2;表达式3;)
>>+ {//复合语句循环体
>>+    }
>>+ 第一次进入循环的时候执行表达式1，表达式1只干一次
>>+ 表达式2是循环的条件，只有表达式2为真了，才执行循环体，也就是说每次进入循环体之前要判断表达式2是否为真
>>+ 每次执行完循环体之后，首先执行表达式3
>>+ 执行顺序：
>>>+ 先执行表达式1，然后执行表达式2，弱国表达式2成立，则执行语句块
>>>+ 当语句块执行完毕之后，接着执行表达式3然后执行表达式2
>>>+ 如果表达式2成立，则继续执行语句块，以此类推，知道表达式2不成立，循环结束、
>+ 2、while循环
>>+ 形式1：
>>>+ while(条件表达式)
>>>+ {
>>>+ //循环体，复合语句
>>>+ 语句块
>>>+     }
>>>+ 执行顺序：
>>>>+ 首先判断while后面的标间表达式，如果表达式成立（为真），执行语句块，执行完语句块接着在次执行条件表达式，如果表达式为真，则继续执行语句块，直到条件表达式为假，循环结束
>>+ 形式2: do while
>>>+ do{
>>>+ //循环体
>>>+ 语句块
>>>+     }while（条件表达式）;
>>>+ 执行顺序：
>>>>+ 先执行do后面的语句块，然后判断while后面的条件表达式是否成立，如果成立，则继续执行dp后面的语句块，执行完毕后接着执行while后面的条件表达式，当条件表达式不成立时，循环结束
>>>+ 注意：
>>>>+ 不管条件是否成立，do后面的语句都会执行一次，所以尽量少用do while
>+ 3、goto循环
>>+ goto主要用于在一个函数里面实现代码的跳转
### 数组
>+ 数组的概念
>>+ 数组是若干个相同类型的变量在内存中有序存储的集合
>>+ 概念理解：
>>>+ 数组用于存储一组数据
>>>+ 数组里存储的数据类型必须是相同的
>>>+ 数组在内存中会开辟一块连续的空间
### ASCII表
>+ https://www.cnblogs.com/biaochen/p/11307382.html
### 动态内存分布malloc
>+ include<stdlib.h>
>+ void * malloc(size_t size);
>+ 像malloc申请的空间的大小是以字节为单位的
>+ 返回的结果是void* 需要类型转换为自己需要的类型
>+ （int*）malloc(n*sizeof(int))
>+ 最后归还内存 free();好借好还再借不难
### free()函数
>+ 把申请得来得空间还给‘系统’
>+ 申请过得空间，最终都应该要还
>+ 出来混迟早是要还得
>+ 只能还申请得来得空间得首地址
### putchar宏
>+ 如果一个宏的值中有其他宏的名字，也是会被替换的
>+ 如果一个宏的值超过一行，最后一行之前的行末需要加\
>+ 宏的值后面出现的注释不会被当作宏的值的一部分
### 没有值的宏
>+ #define _DEBUG
>+ 这类宏是用于条件编译的，后面有其他的编译预处理指令来检查这个宏是否已经被定义过了
### 预定义的宏
>+
### strlen
>+ size_t strlen(const char *s);
>+ 返回 S的字符串长度
### 自定义数据类型 typedef
>+ 声明新的类型的名字
>>+ 新的名字hi某种类型的别名
>>+ 改善了程序的可读性
### 宏定义
>+ # define
>+ # #define<名字><值>
>+ 注意没有结尾的分号，因为不是c的语句
>+ 名字必须是一个单词，值可以是各种东西
>+ 在c语言的编译器开始编译之前，编译预处理程序（cpp）会把程序中的名字换成值
>+ 完全被的文本替换
>+ gcc -save-temps
### 头文件
>+ 把函数原型放到一个头文件（以.h结尾）中，在需要调用这个函数的源代码文件（.c文件）中#include这个头文件，就能让编译器在编译的时候知道函数的原型
### >#include的误区
>+ # #include不是用来引入库的
>+ stdio.h里只有printf的原型，printf的代码在另外的地方，某个.lib(windows)或.a(unix)中
>+ 现在的c语言编译器默认会引入所以的标准库
>+ # #include<stdio.h>只是为了让编译器知道printf函数的原型，保证你调用时给出的参数值是正确的类型
### 不对外公开的函数
>+ 在函数前面加上static就使得它为只能在所在的编译单元中被使用的函数
>+ 在全局变量前面加上static就使得她成为只能在所在的编译单元中被使用的全局变量
###声明函数extern 变量的声明
>+ int i;是变量的定义
>+ extern int i;声明函数
###声明和定义
>+ 声明是不产生代码的东西
>>+ 函数原型
>>+ 变量的声明
>>+ 结构的声明
>>+ 宏声明
>>+ 枚举声明
>>+ inline函数
>+ 定义是产生代码的东西
###头文件
>+ 只有声明可以被放在头文件中
>>+ 是规则不是法律
>+ 否则会造成一个项目中多个编译单元里有重名的实体
>>+ *某些编译器允许几个编译单元中存在同名的函数。或者用weak修饰符来强调这种的存在
###文件的读写fopen
>+ r  打开只读
>+ r+ 打开读写从文件头开始
>+ w 打开只写，如果不存在则新建，如果存在则清空
>+ w+ 打开读写，如果不存在则新建如果存在则清空
>+ a  打开追加，如果不存在则新建，如果存在则从文件尾开始
>+ ..x 只新建，如果文件已存在则不能打开
### 二进制文件
>+ 其实所有的文件最终都是二进制的
>+ 文本文件无非是用最简单的方式可以去读写的文件
>>+ more、tail
>>+ cat
>>+ vi
>+ 而二进制文件是需要专门的程序文件去读写的文件
>+ 文本文件的输入输出是格式化，可能经过转码
###按位运算
>+ c有这谢按位运算的运算符
>+ & 按位的与
>+ | 按位的或
>+ ~按位取反
>+ ^按位的异或
>+ <<左移
>+  .>>右移 
###按位与&
>+ 如果(x)i ==1并且(y)i==1,那么(x&y)i=1
>+ 否则的话(x&y)i =0;
>+ 按位与常用与两种应用:
>>+ 让某以为或某些位为0:x&0xFE
>>+ 取一个数中的一段： x& 0xFF 
### 左移<<
>+ i<<j
>+ i中所有的位向右移动j个位置，而右边填入0
>+ 所有小于int的类型，移位以int的方式来做结果是int
>+ x <<=1 等价于x * = 2
>+ x<<=n等价于x*=2N
>### c语言深度解剖
### Gcc的使用机器常用选项介绍
>+ 重点
>>+ 掌握c语言如何编程机器指令的过程
>>+ gcc工具的几个常用选项的意义
>+ 难点
>>+ c编译过程中在gcc工具上的体现
###GCC概述
>+ GCC最初的全名是GNU C Compiler
>+ 随着GCC支持的语言越来越多，它的名称变成了GNU compiler collection
>+ 翻译官 翻译组织
>+ gcc-o output
>+ gcc -o 输出的文件名，输入文件名
### 指针(重点)
>+ 指针定义：操作系统给每个存储单元分配一个编号，从0x00 00 00 00 ~0xff ff ff
>+ 这个编号称之为地址
>+ 指针就是地址
>+ 指针变量：是个变量，是个指针变量，即这个变量用来存放一个地址编号
>+ 在32位平台下，地址总线是32位，所以地址是32位编号，所以指针变量是32位的即四个字节
>+ 注意1：
>>+ 无论什么类型的地址，都是存储单元的编号，在32位平台下都是4个字节，即任何类型的指针变量都是4个字节大小
>>+ 2: 对应类型的指针的变量，只能存放对应类型的变量的地址
>>+ 举例：整型的指针变量，只能存放整型变量的地址
>+ 扩展：
>>+ 字符变量 char ch;ch占1个字节，它有一个地址编号，这个地址编号就是ch的地址
>>+ 整型变量 int a; a占四个字节，它占有四个字节的存储单元，有四个地址编号
### 指针的定义方法
>+ 1、简单的指针
>>+ 数据类型 * 指针变量名
>>+ int *p;//定义了一个指针变量p
>>+ 在定义指针变量的时候 * 是用来修饰变量的，说明变量p是个指针变量。
>>+ 变量名是p
>+ 2、关于指针的运算符
>>+ &取地址、 *取值
>>+ &：获取一个变量的地址
>>+ *: 在定义一个指针变量时，起到标识作用，标识定义的是一个指针变量除此之外其他地方都标售获取一个指针变量保存的地址里面的内容
>>+ 扩展：如果在一行中定义多个指针变量，每个指针变量前面都需要加*来修饰
>>+ int*p,*q//定义了一个整型指针变量p，和整型的变量q
>+ 指针大小
>>+ 在32位系统下，所以类型的指针都是4个字节，64位系统是8个字节
>>+ 因为不管地址内的空间多大，但是地址编号的长度是一样的，所以在32位系统中，地址都是四个字节
>+ 指针的分类
>>+ 1、字符型指针
>>>+ 字符型数据的地址
>>>+ char *p;//定义了一个字符型指针变量，只能存放字符型数据的地址编号
>>>+ char ch;
>>>+ p = &ch;
>>+ 2、短整型指针
>>>+ short int  *p; //定义一个短整型的指针变量p，只能存放短整型变量的地址 
>>>+ short int a;
>>>+ p = &a;
>>+ 3、整型指针
>>>+ int *p;//定义了一个短整型的指针变量p，只能存放整型变量的地址
>>>+ int a;
>>>+ p = &a;
>>+ 4、长整型
>>>+ long int *p;//定义一个长整型的指针变量p只能存放长整型的地址
>>>+ long int a;
>>>+ p = &a;
>>+ 5、float 型的指针
>>>+ float *p;//定义了一个float型的指针变量p，只能存放float型变量的地址
>>>+ float a;
>>>+ p= &a;
>>+ 6、double型的指针
>>>+ double *p ;//定义了一个double型的指针的变量p，只能存放double型变量的地址
>>>+ double a;
>>>+ p = &a;
>>+ 7、函数指针
>>+ 8、结构体指针
>>+ 9、指针的指针
>>+ 10、数组的指针
### 总结：无论什么类型的指针变量，在32位系统下，都是4个字节，只能存放对应类型的变量的地址编号
### 指针和变量的关系
>+ 指针可以存放变量的地址编号
>>+ 在程序中，引用变量的方法
>>+ 1、直接通过变量名称
>>>+ int a;
>>>+ a= 100;
>>+ 2、可以通过指针变量来引用变量
>>>+ int *P;//在定义的时候，*不是取值的意思，而是修饰的意思，修饰p是个指针变量
>>>+ p = &a;//取a的地址给p赋值，p保存了a的地址，也可以说p指向了a
>>>+ *p =100;//在调用的时候*是取值的意思，*指针变量，等价于指针指向的变量
>+ 注：指针变量在定义的时候可以初始化
>>+ int a;
>>+ int *p = &a;//用a的地址，给p赋值，因为p是指针变量，指针就是用来存放变量的地址的
>>+ *+指针变量 就相当于指针指向的变量
>+ 扩展：
>>+ 对应类型的指针，只能保存对应类型数据的地址
>>+ 如果想让不同类型的指针相互赋值的时候，需要强制类型转换
>+ 注意：
>>+ 1、*+指针 取值，取几个字节，由指针类型决定的指针位字符指针则取一个字节，指针位整型指针则取4个字节，指针位double型指针则取8个字节
>>+ 2、指针++指向下个对应类型的数据
>>>+ 字符指针++ ，指向下个字符数据，指针存放的地址编号加1
>>>+ 整型指针++ 指向下个整型数据，指针存放的地址编号加4
### 指针和数组元素之间的关系
>+ 1、
   > > 变量存放在内存中，有地址编号，咱们定义的数组，是多个相同类型的变量的集合，每个变量都占内存空间，都有地址编号，指针变量当然可以存放数组元素的地址
>>>+ 例：
>>>>+ int a[10];
>>>>+ //int *p = &a[0];
>>>>+ int *p;
>>>>+ p = &a[0];
>>>>+ 指针变量p博爱村了数组a中的第0个元素的地址即a[0]的地址
>+ 2、数组元素的引用方法
>>+ 方法1：数组名【下标】
>>>+ int a[10];
>>>+ a[2]=100;
>>+ 方法2：指针名加下标
>>>+ int a[10];
>>>+ int *p;
>>>+ p = a;
>>>+ p[2]=100;//因为p和a等价
>>+ 补充：c语言规定：数组的名字就是数组的首地址，即第0个元素的地址，是个常量
>>+ 注意：p和a的不同，p是指针变量，所以可以用等号给p赋值，单不能给a赋值
>>+ 方法3、通过指针运算加取值的方法来引用数组的元素
>>>+ int a[10];
>>>+ int *p;
>>>+ p = a;
>>>+ *(p+2)=100;//也是可以的，相当于a[2]这个元素的地址。对第二个元素的地址取值即a[2]
### 指针的运算
>+ 1、指针可以加一个整数，往下指几个它指向的变量，结果还是个地址
>+ 前提：指针指向数组的时候，加一个整数才有意义
>>+ 例：
>>+ int a[10];
>>+ int *p,*q;
>>+ p = a;
>>+ q=p+2;//是a[0]的地址，p+2是&a[2]
>+ 假如p包含 你的地址编号是2000的话p+2代表的地址编号是2008
>>+ 例
>>+ char buf[10];
>>+ char *q;
>>+ q = buf;
>>+ q+2//相当于&buf[2]
>>+ 假如：q中存放的地址编号是2000的话，q+2代表的地址编号是2002
>+ 2、两个相同类型指针可以比较大小 代码见main.c
>>+ 前提：只有相同类型的指针指向同一个数组的元素的时候，比较大小才有意义
>>+ 指向前面元素的指针 小于 指向后面 元素的指针
>+ 3、两个相同类型的指针可以做减法
>>+ 前提：必须是两个相同类型的指针指向同一个数组元素的时候，做减法才有意义
>>+ 做减法的结果是，两个指针指向中间有多少元素
>>+ 代码见main.c
>+ 两个相同类型的指针可以相互赋值 代码见main.c texe4()
>>+ 注意：只有相同类型的指针才可以相互赋值（void*类型的除外）
>>+ int *p;
>>+ int*q;
>>+ int a;
>>+ p = &a;//p 保存的a的地址，p指向了变量a
>>+ q=p;//用p给q赋值，q也保存了a的地址，指向a
>>+ 注意：如果类型不同的指针要想相互赋值，必须进行强制类型转换
>+ 注意：c语言规定数组的名字，就是数组的首地址，就是数组第0个元素的地址
### 指针数组
>+ 1、指针和数组的关系
>>+ 1:指针可以保存数组元素的地址
>>+ 2:可以定义一个数组，数组中有若干个相同类型指针的变量，这个数组被称为指针数组
>>+ 指针数组的概念：
>>>+ 指针数组本身是个数组，是个指针数组，是若干个相同类型的指针变量构成的集合
>+ 2、指针数组的定义方法：
>>+ 类型说明符 * 数组名 [元素个数];
>>+ int * p[10];定义一个整型的指针数组p， 有10个元素p[0]~p[9],
>>+ 每个元素都是int * 类型的变量
>>+ int a;
>>+ p[1]=&a;
>>+ int b [10];
>>+ p[2]=&b[3];
>>+ p[2]、*(p+2)是等价的，都是指针数组中的第二个元素
>+ 3、指针数组的分类